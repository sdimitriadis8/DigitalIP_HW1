%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
%&%                                                   %&%
%&%        Εργασία Δημητριάδη Σωκράτη Α.Μ.:359        %&%
%&%                                                   %&%
%&%    Τ.08 - ΘΕΜΑΤΑ ΨΗΦΙΑΚΗΣ ΕΠΕΞΕΡΓΑΣΙΑΣ ΕΙΚΟΝΑΣ    %&%
%&%          ΣΥΜΠΙΕΣΗ ΚΑΙ ΥΠΕΡΑΝΑΛΥΣΗ ΒΙΝΤΕΟ          %&%
%&%                                                   %&%
%&%           1Η ΠΡΟΓΡΑΜΜΑΤΙΣΤΙΚΗ ΑΣΚΗΣΗ              %&%
%&%                     ΜΕΡΟΣ 3                       %&%
%&%                                                   %&%
%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
%--------------------------------------------------------
% Μέρη 3.1 & 3.2:
% -----------------
% Φόρτωση της εικόνας, που θέλουμε να 
% επεξεργαστούμε, από τη μνήμη
f=imread('cameraman.tif');

% Η fun είναι η συνάρτηση που παίρνει ως όρισμα η blockproc.
fun = @(block_struct) Turn2Dto1D(block_struct.data);
% Εδώ ορίσαμε ως συνάρτηση εφαρμογής την Turn2Dto1D,
% για να μετατρέψουμε κάθε 8x8 μπλοκ σε διάνυσμα 64x1

% Στη συνέχεια εφαρμόζουμε τη συνάρτηση στην blockproc κατά μλοκ 8x8                    
I2 = blockproc(f,[8 8],fun);  % Έτσι, η blockproc, όπως προσαρμόστηκε
                              % στο πρόβλημά μας, έχει αυτή τη μορφή.

% Διατάσσω τα δινύσματα της μορφής 64x1 από τον πίνακα f,
% που τα έχει τοποθετήσει με την 8x8 επεξεργασία, το ένα δίπλα
% στο άλλο για τις 32(256/8) γραμμές, σε στήλες
Si=ColOrd(I2); % Ώστε τα διανύσματα s(i), είναι οι στήλες του πίνακα
               % και είναι διαστάσεων 64x1 και 1024 σε πλήθος.
%%
% Μέρος 3.3:
% ----------
% Για τον υπολογισμό της μέσης τιμής, η(s) των s(i) έχουμε:
sumSi=zeros(64,1); % Αρχικοποίηση των πινάκων ύστερα από
hs=zeros(64,1);    % προτροπή της Matlab
Si=double(Si); % (Δεν άθροιζε τα s(i), αν δεν ήταν double)
for j=1:64
    for k=1:1024
       sumSi(j)=sumSi(j)+Si(j,k); % Αθροίζω σε κάθε γραμμή, τις 
                                  % ομώνυμες συντεταγμένες των s(i)
    end
    hs(j)=1/1024*sumSi(j); % Διαιρώ κάθε στοιχείο με 1024
end
%%
% Μέρος 3.3:
% ----------
% Για τον υπολογισμό του πίνακα συνδιακύμανσης [C], έχουμε:
diffs=zeros(64,1024); % Αρχικοποίηση του πίνακα διαφορών
for j=1:64
        for k=1:1024
            diffs(j,k)=Si(j,k)-hs(j); % Υπολογίζω τις διαφορές των S(i)
                                      % από τις αντίστοιχες μέσες τιμές
        end
end
% Έτσι ο πίνακας συνδιακύμανσης, [C], είναι ο παρακάτω:
C=1/1024*(diffs*diffs'); 
%%
% Μέρος 3.4:
% ----------
% Υπολογίζουμε τα ιδιοδιανύσματα και τις ιδιοτιμές του
% πίνακα συνδιακύμανσης, στους πίνακες V και D αντίστοιχα
[V,D] = eig(C);
% Χάρην πληρότητας και γενικευτικής δυνατότητας,
% κανονικοποιώ τα ιδιοδιανύσματα του [C],
% που είναι οι στήλες του V ως εξής:
% Υπολογίζω τη νόρμα κάθε διανύσματος-στήλης...
for j=1:64
    n(j)=norm(V(:,j)); 
end
% ... και διαιρώ κάθε στήλη με την παραπάνω ποσότητα
for j=1:64
    Phi(:,j)=1/n(j)*V(:,j); % (Κανονικοποίηση ιδιοδιανυσμάτων)
end
% Αυτός είναι και ο ζητούμενος πίνακας [Φ], του αντίστροφου KLT
%%
% Μέρος 3.5:
% ----------
% Για τον υπολογισμό του KLT κάθε διανύσματος s(i), έχουμε:
Ti=Phi'*Si; % Δηλαδή, όπως ξέραμε από τη θεωρία t=[V]s ή t=[Φ]'s
            % αφού s=[U]t και [U]=[V]'=[Φ].
%%
% Μέρος 3.6:
% ----------
% Τώρα, από τον πίνακα των t(i), επιλέγουμε τους
% 20 κατά-απόλυτη-τιμή-μεγαλύτερους συντελεστές
% και μηδενίζουμε τους υπόλοιπους
for j=1:1024
    Ti20Max(:,j)=howmax(Ti(:,j),20);
end
%%
% Μέρος 3.7:
% ----------
% Υπολογίζουμε τον αντίστροφο KLT των παραπάνω διανυσμάτων
% και έχουμε τα νέα διανύσματα ~s(i)
SiNew20=Phi*Ti20Max;

% Τώρα, μετατρέπουμε τα 64x1 διανύσματα-στήλες σε 8x8 μπλοκ,
% όπως ήταν στην αρχή (καλείται η συνάρτηση Turn1Dto2D σε
% κάθε διάνυσμα 64x1, για αυτόν τον σκοπό)
h=0;
t=0;
NewImg20=zeros(256);
for j=1:1024
  Block8x8=Turn1Dto2D(SiNew20(:,j)); % Προσωρινή αποθήκευση του
                                   % κάθε διανύσματος για χρήση του
                                   % αντίστοιχου 8x8 μπλοκ, για να
                                   % εκτελεστεί κατάλληλη διάταξη
  % Διατάσσουμε κατάλληλα τα μπλοκς όπως ήταν 
  % στην αρχική εικόνα
  for k=1:8
      for l=1:8
          NewImg20(k+h,l+t)=Block8x8(k,l); % Ανάθεση του 8x8 μπλοκ 
                                           % στη νέα εικόνα
      end
  end
  if t+8==256 % Κάθε φορά που ολοκληρώνεται μία πλήρωση 256 στηλών
      h=h+8;  % μεταφερόμαστε 8 γραμμές κάτω και μηδενίζουμε 
      t=0;    % τον μετρητή των στηλών για να επαναληφθεί η διαδικασία
  else
      t=t+8;  % Σε περίπτωση που δεν έχει ολοκληρωθεί η πλήρωση
              % μεταφερομαστε 8 στήλες δεξιά
  end
end

figure('Name','IKLT 20')     % Εκτύπωση της εικόνας έπειτα από
imshow(NewImg20);            % την επεξεργασία 
NewImg20=uint8(NewImg20);
figure('Name','IKLT(UINT8) 20')     % Εκτύπωση της εικόνας σε μορφή uint8
imshow(NewImg20); 
psnr20KLT = psnr(NewImg20,f) % Υπολογισμός του PSNR 

%%
% Μέρος 3.8:
% ----------
% Τέλος, από τον πίνακα των t(i), επιλέγουμε τους
% 10 κατά-απόλυτη-τιμή-μεγαλύτερους συντελεστές
% και μηδενίζουμε τους υπόλοιπους
for j=1:1024
    Ti10Max(:,j)=howmax(Ti(:,j),10);
end

% Υπολογίζουμε τον αντίστροφο KLT των παραπάνω διανυσμάτων
% και έχουμε
SiNew10=Phi*Ti10Max;

% Τώρα, μετατρέπουμε τα 64x1 διανύσματα-στήλες σε 8x8 μπλοκ,
% όπως ήταν στην αρχή, όπως κάναμε και πριν
% (τα σχόλια στις αντίστοιχες εντολές παραλείπονται εδώ)
h=0;
t=0;
NewImg10=zeros(256);
for j=1:1024
  Block8x8=Turn1Dto2D(SiNew10(:,j));
  for k=1:8
      for l=1:8
          NewImg10(k+h,l+t)=Block8x8(k,l);
      end
  end
  if t+8==256
      h=h+8;
      t=0;
  else
      t=t+8;
  end
end

figure('Name','IKLT 10')     % Εμφάνιση της εικόνας μετά από
imshow(NewImg10);            % την επεξεργασία 
NewImg10=uint8(NewImg10);
figure('Name','IKLT(UINT8) 10')% Εκτύπωση της εικόνας σε μορφή uint8
imshow(NewImg10); 
psnr10KLT = psnr(NewImg10,f) % Υπολογισμός του PSNR

